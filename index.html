<!DOCTYPE html>
<html>

<head>
    <meta charset='utf-8'>
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <meta name="description" content="ILI9341_due : Arduino Due library for interfacing with ILI9341 SPI TFTs">

    <script src="javascripts\lodash.js" type="text/javascript"></script>
    <link rel="stylesheet" type="text/css" media="screen" href="stylesheets/stylesheet.css">

    <title>ILI9341_due</title>
</head>

<body>

    <!-- HEADER -->
    <div id="header_wrap" class="outer">
        <header class="inner">
            <a id="forkme_banner" href="https://github.com/marekburiak/ILI9341_due">View on GitHub</a>

            <h1 id="project_title">ILI9341_due</h1>
            <h2 id="project_tagline">Arduino Due library for interfacing with ILI9341 SPI TFTs</h2>

            <section id="downloads">
                <a class="zip_download_link" href="https://github.com/marekburiak/ILI9341_due/zipball/master">Download this project as a .zip file</a>
                <a class="tar_download_link" href="https://github.com/marekburiak/ILI9341_due/tarball/master">Download this project as a tar.gz file</a>
            </section>
        </header>
    </div>



    <!-- MAIN CONTENT -->
    <div id="main_content_wrap" class="outer">
        <section id="main_content" class="inner">
            <h1>
                <a name="ili9341_due" class="anchor" href="#ili9341_due"><span class="octicon octicon-link"></span></a>ILI9341_due
            </h1>

            <p>Arduino Due library for interfacing with ILI9341-based TFT's in SPI, Extended SPI and DMA SPI mode.</p>

            <p>This library is based on 3 libraries:</p>

            <p>
                <b>ili9341_t3</b> from Paul Stoffregen - <a href="https://github.com/PaulStoffregen/ILI9341_t3">https://github.com/PaulStoffregen/ILI9341_t3</a><br>
                <b>SdFat</b> from Bill Greiman - <a href="https://github.com/greiman/SdFat">https://github.com/greiman/SdFat</a><br>
                <b>GLCD</b> from Michael Margolis and Bill Perry - <a href="https://code.google.com/p/glcd-arduino">https://code.google.com/p/glcd-arduino</a><br>
            </p>

            <p>
                ili9341_t3 library where various optimizations for Adafruit's ili9341 and GFX libraries were implemented was used as a base for ili9341_due.<br>
                One class from SdFat library is used for utilizing Due's DMA in SPI transfers which provides the main speed boost.<br>
                gText class from GLCD library was used as a base for rendering custom fonts.
            </p>

            <p>
                As for the wiring, use Due's HW SPI pins (e.g. described <a href="http://21stdigitalhome.blogspot.com/2013/02/arduino-due-hardware-spi.html">here</a>). A pin for CS depends on the SPI mode you choose.
                If you look into ILI9341_due.h, you should find this:
            </p>

            <pre lang="Arduino"><code>// comment out the SPI mode you want to use
//#define ILI9341_SPI_MODE_NORMAL
//#define ILI9341_SPI_MODE_EXTENDED // make sure you use pin 4, 10 or 52 for CS
#define ILI9341_SPI_MODE_DMA</code></pre>

            <p>Uncomment the line depending on the SPI mode you want to use. As you can see, DMA mode is the default.</p>

            <p>
                <b>SPI_MODE_NORMAL</b> is the standard SPI mode where you can use any digital pin for CS but you/library has to drive it manually.<br>
                <b>SPI_MODE_EXTENDED</b> is the extended SPI mode available in Due where CS pin is handled by the chip (which is faster than handling it manually). You are restricted to these pins for CS though - 4, 10 and 52 (as described <a href="http://arduino.cc/en/Reference/DueExtendedSPI">here</a>).<br>
                <b>SPI_MODE_DMA</b> is utilizing DMA to do SPI transfers. You should be able to use any digital pin for CS.
            </p>

            <p>
                Here is a video where you can see the speed difference between the modes:
            </p>
            <div style="text-align: center">
                <iframe width="560" height="315" src="http://www.youtube.com/embed/vnEwzN14BsU?rel=0&color=white" frameborder="0"></iframe>
            </div>
            <br />
            <pre lang="Arduino"><code>#define ILI9341_SPI_CLKDIVIDER 2</code></pre>

            <p>This is used to set the SPI clock frequency, which at 2 means 84/2=42MHz (the max). If you are getting glitches on the screen or it just does not work try to use a higher divider to bring the frequency down (e.g. 11 to run it at 8-ish MHz). I was using 20cm dupont cables to connect TFT with Due and haven't had any issues running it with the divider set to 2.</p>

            <p>If you want to ask me a question or just contact me, feel free to do so in the <a href="http://forum.arduino.cc/index.php?topic=265806.0">Arduino Forum</a>.</p>

            <h3>ILI9341 functions</h3>

            <div id="iliFunctions">

            </div>

            <h3>Rendering custom fonts with ILI9341_due_gText</h3>

            <p>
                You have two options for rendering fonts. Either use text functions from ILI9341_due library where you have one font available (same as in Adafruit's GFX library) or use ILI9341_due_gText class to render your custom fonts.
                The maximum height of the font is 255px. Custom font .h files can be generated with GLCDFontCreator2 tool (requires Java). It is included in the tools folder or you can dowload it from
                <a href="https://code.google.com/p/glcd-arduino/downloads/detail?name=GLCDFontCreator2.zip&amp;can=2&amp;q=">here</a>.<br>
                Here is a video of rendering a 255px-high font:
            </p>
            <div style="text-align: center">
                <iframe width="560" height="315" src="http://www.youtube.com/embed/OcTz_YBDXmo?rel=0&color=white" frameborder="0"></iframe>
            </div>
            <h3>Loading images from an SD card</h3>

            <p>This is the SdFatTftBitmap example sketch demonstrating loading images from an SD card. The images were converted to RGB565 format using BMP24toILI565 tool (see the Tools folder). One image loads and displays in around 190ms (using half speed for SD card SPI as the full speed did not work for me, probably because the SD card pins were connected to Due via a breadboard).</p>
            <div style="text-align: center">
                <iframe width="560" height="315" src="http://www.youtube.com/embed/4adTpVc_Qog?rel=0&color=white" frameborder="0"></iframe>
            </div>
            <h3>Drawing Arcs</h3>
            <p>You can use the <i>drawArc</i> method to draw arcs (with thickness) and depending on the thickness and angles you provide as parameters you might also draw pies and circles with thickness.</p>
            <p>ILI9341_due.h has two defines which you can customize:</p>

            <pre lang="Arduino"><code>#define ARC_ANGLE_MAX 360</code></pre>
            <p>
                This number represents the maximum equal to 360 degrees (full circle). The default is 360 so if you pass in start=25 and end=75 you'll get an arc going from 25 degrees to 75 degrees.
                If you set ARC_ANGLE_MAX 100 and you pass in start=0 and end=50 then you get a half circle (that can represent percentages). If you set ARC_ANGLE_MAX 2*PI, you can pass in
                angles in radians etc...
            </p>

            <pre lang="Arduino"><code>#define ARC_ANGLE_OFFSET -90</code></pre>

            <p>This number is an offset in degrees from the default position where the arc starts (representing value of 0). If you imagine a compass, then the default starting position is at the East point. Setting the value to -90 will move the starting point 90 degress counter-clockwise (so to the North point).</p>
            <p>You can change these defaults at runtime by calling setArcParams function.</p>

            <p>This is the Arcs demo from the examples folder:</p>
            <div style="text-align: center">
                <iframe width="560" height="315" src="http://www.youtube.com/embed/99todZeKaeI?rel=0&color=white" frameborder="0"></iframe>
            </div>
            <h3>Taking screenshots</h3>

            <p>
                The library has a method called <i>screenshotToConsole</i>. When you call that method, you should get a string like this one in the console window:
            </p>

            <pre lang="Arduino"><code>==== PIXEL DATA START ====
0000000090606060001F000000011B606060002B0000000
11060606000350000000107606060003D00000000FF6060
60004500000000F86060600016000000001F60606000160
...                                     
0000000F26060600013000000002B606060001300000000
EC6060600011000000001B7C7E7C000E000000000C60606
06060002B000000011B606060001F00000001D1000050F0
==== PIXEL DATA END ====</code></pre>

            <p>
                Now, copy all between PIXEL DATA START and END (so starting with 0000... and ending with ...50F0) into the clipboard.<br />
                Open ILIScreenshotViewer (from the tools folder) and click "Load Image from Clipboard" button. You should then see an image
                of what was on the screen when you called <i>screenshotToConsole</i> method.
            </p>
            <div style="text-align: center">
                <img src="images\ILIScreenshotViewer.png" />
            </div>
            <p>You can then click "Save As..." button to save the image in bmp, gif, png or jpg format.</p>
            <p>
                A couple of tips:
                <ul>
                    <li>
                        Use some higher Serial speed. Depending on the image, the "screenshot" string might get long (in kB) so I guess transferring it at 115200b/s is better than at 9600b/s.
                    </li>
                    <li>
                        If your get an error after you click the Load Image from Clipboard button or your image has artifacts, try lowering the SPI clock before you call screenshotToConsole method.
                        Something like this:
                        <pre lang="Arduino"><code>tft.setSPIClockDivider(24);  // lower the frequency
tft.screenshotToConsole();   // take a "screenshot"
tft.setSPIClockDivider(ILI9341_SPI_CLKDIVIDER); // restore the frequency</code></pre>
                    </li>
                </ul>
            </p>

            <h3>UTFT demo speed comparison</h3>

            <p>All the credits (and blame :) goes to TFTLCDCyg who ported the UTFT demo to ILI9341_due library. Both demos were run on Due at the max speed.</p>
            <p>Here is a video of the demo powered by the UTFT library:</p>
            <div style="text-align: center">
                <iframe width="560" height="315" src="http://www.youtube.com/embed/ZYW9f8Q_b-Q?rel=0&color=white" frameborder="0"></iframe>
            </div>
            <p>And here is the demo powered by the ILI9341_due library:</p>
            <div style="text-align: center">
                <iframe width="560" height="315" src="http://www.youtube.com/embed/xkPDAK0VJq0?rel=0&color=white" frameborder="0"></iframe>
            </div>
            <p>The source code for the ILI9341_due-fied demo can be found in the library's examples folder.</p>

            <h3>AVR compatibility</h3>

            <p>The library can also be used with Arduino AVR boards like Uno, Mega, Pro Mini, Nano, etc.</p>
            <div style="text-align: center">
                <img src="images\avr.jpg" />
            </div>
            <p>
                The only mode available for AVR is SPI_MODE_NORMAL so you need to include SPI.h in your sketch. The library is faster than the original Adafruit one but do not expect DMA-like speed increase. It is comparable to some other tweaked Adafruit libraries out there and you get things like gText and arcs.
                Not all library examples will work. It is because of smaller ROM/RAM space available on AVRs.
            </p>
            <p>
                In order to decrease ROM/RAM requirements, you can comment out 2 features in ILI9341_due.h:
                <pre lang="Arduino"><code>// commenting out/disabling the ARC feature will exclude the drawArc function. It is going to save a few ROM bytes.
#define FEATURE_ARC_ENABLED
// commenting out/disabling the PRINT feature will exclude the drawChars and print functions, it saves around 3.6kB ROM and 1.3kB RAM(!)
// I recommend using gText for drawing the text.
#define FEATURE_PRINT_ENABLED</code></pre>
                I highly recommend to disable the PRINT feature if you are not using .print function (to draw blocky text). It will save you 1.3kB of RAM (of 2kB available on Uno). You can use gText instead.
            </p>
            <p>
                <h4>Using gText on AVR</h4>
                If you are using your custom fonts (generated with GLCDFontCreator2) you need to manually modify the generated .c file in order to make it succesfully compile for AVR. After you generate the .c file the array definition will look something like this:
            </p>
            <pre lang="Arduino"><code>static uint8_t Arial_14[] PROGMEM = {</code></pre>

            <p>
                If you do not change anything the compiler will complain with:
            </p>
            error: variable 'Arial_14' must be const in order to be put into read-only section by means of '__attribute__((progmem))'<br /><br />
            In order to fix it you need to add "const" so it will look like this:

            <pre lang="Arduino"><code>static const uint8_t Arial_14[] PROGMEM = {</code></pre>

            <br />
            <h3>Known bugs/issues/missing functionality</h3>

            <ul>
                <li>I am sure there are bugs, feel free to fix them</li>
                <li>New line is not handled when rendering with gText</li>
            </ul>
            <p>I plan to add some more features (like handling the new line and scrolling in gText) but I am not sure when will that happen as I have very little time to work on it (if I want to get at least 5 hours of sleep). So feel free to enhance the lib.</p>

            <pre><code>------------------------------------------
This is a library for the Adafruit ILI9341 display products
This library works with the Adafruit 2.8" Touch Shield V2 (SPI)
  ----&gt; http://www.adafruit.com/products/1651
Check out the links above for our tutorials and wiring diagrams.
These displays use SPI to communicate, 4 or 5 pins are required
to interface (RST is optional).
Adafruit invests time and resources providing this open source code,
please support Adafruit and open-source hardware by purchasing
products from Adafruit!
Written by Limor Fried/Ladyada for Adafruit Industries.
MIT license, all text above must be included in any redistribution
</code></pre>
        </section>
    </div>

    <!-- FOOTER  -->
    <div id="footer_wrap" class="outer">
        <footer class="inner">
            <p class="copyright">ILI9341_due maintained by <a href="https://github.com/marekburiak">Marek Buriak</a></p>
            <p>Published with <a href="http://pages.github.com">GitHub Pages</a></p>
        </footer>
    </div>

    <div class="function">
        <div class="functionHeader">
            drawLine
        </div>
        <div class="functionDescription">
            Draws a line defined by start and end points.
        </div>
        <div class="functionExample">
            <div class="functionExampleDescription">

            </div>
            <div class="functionExampleCode">

            </div>
        </div>
        <div class="functionImage">
            <img src="images\func_drawLine.png" />
        </div>
    </div>

    <script type="text/javascript">
        function addIliFunction(functionName, functionDescription, functionDeclarationCode, functionArguments, functionExampleDesc, functionExampleCode, includeImage, functionExampleImage) {
            var funcs = document.getElementById("iliFunctions");
            var funcElem = document.createElement("div");
            funcElem.className = "function";

            var funcHeader = document.createElement("div");
            funcHeader.className = "functionHeader";
            funcHeader.appendChild(document.createTextNode(functionName));

            var funcContent = document.createElement("div");
            funcContent.className = "functionContent";

            var funcDesc = document.createElement("div");
            funcDesc.className = "functionDescription";
            funcDesc.innerHTML = functionDescription;

            var funcDeclaration = document.createElement("div");
            funcDeclaration.className = "functionCode";
            funcDeclaration.innerHTML = functionDeclarationCode;
            //if (_.isArray(functionDeclarationCode)) {
            //    _.forEach(functionDeclarationCode, function (functionDeclaration) {

            //        var funcDeclarationOne = document.createElement("div");
            //        funcDeclarationOne.appendChild(document.createTextNode(functionDeclaration));
            //        funcDeclaration.appendChild(funcDeclarationOne);
            //    })
            //}
            //else {
            //    funcDeclaration.appendChild(document.createTextNode(functionDeclarationCode));
            //}

            var funcArgumentsTitle = document.createElement("div");
            funcArgumentsTitle.className = "functionArgumentsTitle";
            funcArgumentsTitle.innerHTML = "Arguments:";

            var funcArguments = document.createElement("div");
            funcArguments.className = "functionArguments";
            funcArguments.innerHTML = functionArguments;

            var funcExample = document.createElement("div");
            funcExample.className = "functionExample";
            var funcExampleTitle = document.createElement("div");
            funcExampleTitle.className = "functionExampleTitle";
            funcExampleTitle.innerHTML = "Example:";

            var funcExampleDesc = document.createElement("div");
            funcExampleDesc.className = "functionExampleDescription";
            funcExampleDesc.innerHTML = functionExampleDesc;
            var funcExampleCode = document.createElement("div");
            funcExampleCode.className = "functionCode";
            funcExampleCode.innerHTML = functionExampleCode;
            //if (_.isArray(functionExampleCode)) {
            //    _.forEach(functionExampleCode, function (functionExample) {

            //        var funcExampleOne = document.createElement("div");
            //        funcExampleOne.appendChild(document.createTextNode(functionExample));
            //        funcExampleCode.appendChild(funcExampleOne);
            //    })
            //}
            //else {
            //    funcExampleCode.appendChild(document.createTextNode(functionExampleCode));
            //}

            if (includeImage) {
                var funcExampleImage = document.createElement("div");
                funcExampleImage.className = "functionExampleImage";
                var funcExampleImageImg = document.createElement("img");
                if (typeof functionExampleImage !== "undefined")
                    funcExampleImageImg.setAttribute("src", ".\\images\\" + functionExampleImage);
                else
                    funcExampleImageImg.setAttribute("src", ".\\images\\func_" + functionName + ".png");

                funcExampleImage.appendChild(funcExampleImageImg);
            }

            funcExample.appendChild(funcExampleTitle);
            funcExample.appendChild(funcExampleDesc);
            funcExample.appendChild(funcExampleCode);
            if (includeImage)
                funcExample.appendChild(funcExampleImage);


            funcContent.appendChild(funcDesc);
            funcContent.appendChild(funcDeclaration);
            funcContent.appendChild(funcArgumentsTitle);
            funcContent.appendChild(funcArguments);
            funcContent.appendChild(funcExample);

            funcElem.appendChild(funcHeader);
            funcElem.appendChild(funcContent);
            funcs.appendChild(funcElem);
        }

        addIliFunction("fillScreen",
        "Fills/clears the whole screen.",
        "void fillScreen(uint16_t color);",
        "<li><em>color</em> - color to fill the screen with",
        "A screen filled with blue color.",
        "tft.fillScreen(ILI9341_BLUE);", true);

        addIliFunction("drawPixel",
        "Draws a pixel.",
        "void drawPixel(int16_t x, int16_t y, uint16_t color);",
        "<ul><li><em>x</em> - x-coordinate</li>" + 
        "<li><em>y</em> - y-coordinate</li>" + 
        "<li><em>color</em> - pixel color</li></ul>",
        "A white pixel at position (100,100).",
        "tft.drawPixel(100, 100, ILI9341_WHITE);", true);

        addIliFunction("drawLine",
        "Draws a line.",
        "void drawLine(int16_t x0, int16_t y0, int16_t x1, int16_t y1, uint16_t color);",
        "<ul><li><em>x0</em> - x-coordinate of the starting point</li>" +
        "<li><em>y0</em> - y-coordinate of the starting point</li>" + 
        "<li><em>x1</em> - x-coordinate of the ending point</li>" + 
        "<li><em>y1</em> - y-coordinate of the ending point</li>" + 
        "<li><em>color</em> - line color</li></ul>",
        "A white line from point (100,100) to point (150,120)",
        "tft.drawLine(100, 100, 150, 120, ILI9341_WHITE);", true);

        addIliFunction("drawLineByAngle",
        "Draws a line defined by a start point and an angle. An offset from the start point can be defined.",
        "void drawLineByAngle(int16_t x, int16_t y, int16_t angle, uint16_t length, uint16_t color);</br>" +
        "void drawLineByAngle(int16_t x, int16_t y, int16_t angle, uint16_t start, uint16_t length, uint16_t color);",
        "<ul><li><em>x</em> - x-coordinate of the starting point</li>" +
        "<li><em>y</em> - y-coordinate of the starting point</li>" + 
        "<li><em>angle</em> - line angle</li>" + 
        "<li><em>start</em> - offset from the starting point (optional)</li>" + 
        "<li><em>lenght</em> - line lenght</li>" + 
        "<li><em>color</em> - line color</li></ul>",
        "A white line from point (100,100) at 45 degree angle and of 50px length. A red line from point (100,100) at 90 degree angle starting 10px from the start point and with length of 50px.",
        "tft.drawLineByAngle(100, 100, 45, 50, ILI9341_WHITE);</br>" +
        "tft.drawLineByAngle(100, 100, 90, 10, 50, ILI9341_RED);", true);

        addIliFunction("drawFastHLine",
        "Draws a horizontal line. Performance optimized version of drawLine for drawing horizontal lines.",
        "void drawFastHLine(int16_t x, int16_t y, uint16_t w, uint16_t color);",
        "<ul><li><em>x</em> - x-coordinate of the starting point</li>" +
        "<li><em>y</em> - y-coordinate of the starting point</li>" + 
        "<li><em>w</em> - line width (line is drawn from left to right)</li>" + 
        "<li><em>color</em> - line color</li></ul>",
        "A white horizontal line from point (100,100) of 50px length.",
        "tft.drawFastHLine(100, 100, 50, ILI9341_WHITE);", true);

        addIliFunction("drawFastVLine",
        "Draws a vertical line. Performance optimized version of drawLine for drawing vertical lines.",
        "void drawFastVLine(int16_t x, int16_t y, uint16_t h, uint16_t color);",
        "<ul><li><em>x</em> - x-coordinate of the starting point</li>" +
        "<li><em>y</em> - y-coordinate of the starting point</li>" + 
        "<li><em>h</em> - line height (line is drawn from top to bottom)</li>" + 
        "<li><em>color</em> - line color</li></ul>",
        "A white vertical line from point (100,100) of 50px length.",
        "tft.drawFastVLine(100, 100, 50, ILI9341_WHITE);", true);

        addIliFunction("drawRect",
        "Draws a rectangle.",
        "void drawRect(int16_t x, int16_t y, int16_t w, int16_t h, uint16_t color);",
        "<ul><li><em>x</em> - x-coordinate of the rectangle's top left corner</li>" +
        "<li><em>y</em> - y-coordinate of the rectangle's top left corner</li>" + 
        "<li><em>w</em> - rectangle width</li>" + 
        "<li><em>h</em> - rectangle height</li>" + 
        "<li><em>color</em> - rectangle color</li></ul>",
        "A white rectangle from point (100,100) of 50px width and of 20px height.",
        "tft.drawRect(100, 100, 50, 20, ILI9341_WHITE);", true);

        addIliFunction("fillRect",
         "Draws a filled rectangle.",
         "void fillRect(int16_t x, int16_t y, int16_t w, int16_t h, uint16_t color);",
         "<ul><li><em>x</em> - x-coordinate of the rectangle's top left corner</li>" +
        "<li><em>y</em> - y-coordinate of the rectangle's top left corner</li>" + 
        "<li><em>w</em> - rectangle width</li>" + 
        "<li><em>h</em> - rectangle height</li>" + 
        "<li><em>color</em> - rectangle fill color</li></ul>",
         "A white filled rectangle from point (100,100) of 50px width and of 20px height.",
         "tft.fillRect(100, 100, 50, 20, ILI9341_WHITE);", true);

        addIliFunction("drawRoundRect",
        "Draws a rectangle with rounded edges.",
        "void drawRoundRect(int16_t x, int16_t y, int16_t w, int16_t h, int16_t radius, uint16_t color);",
        "<ul><li><em>x</em> - x-coordinate of the rectangle's top left corner</li>" +
        "<li><em>y</em> - y-coordinate of the rectangle's top left corner</li>" + 
        "<li><em>w</em> - rectangle width</li>" + 
        "<li><em>h</em> - rectangle height</li>" + 
        "<li><em>radius</em> - corner radius</li>" + 
        "<li><em>color</em> - rectangle color</li></ul>",
        "A white rounded rectangle from point (100,100) of 50px width, 20px height and rounded edges of 7px radius.",
        "tft.drawRoundRect(100, 100, 50, 20, 7, ILI9341_WHITE);", true);

        addIliFunction("fillRoundRect",
         "Draws a filled rectangle with rounded edges of specified radius from the specified position and of specified width and height.",
         "void fillRoundRect(int16_t x, int16_t y, int16_t w, int16_t h, int16_t radius, uint16_t color);",
         "<ul><li><em>x</em> - x-coordinate of the rectangle's top left corner</li>" +
        "<li><em>y</em> - y-coordinate of the rectangle's top left corner</li>" + 
        "<li><em>w</em> - rectangle width</li>" + 
        "<li><em>h</em> - rectangle height</li>" + 
        "<li><em>radius</em> - corner radius</li>" + 
        "<li><em>color</em> - rectangle fill color</li></ul>",
         "A white filled rounded rectangle from point (100,100) of 50px width, 20px height and rounded edges of 7px radius.",
         "tft.fillRoundRect(100, 100, 50, 20, 7, ILI9341_WHITE);", true);

        addIliFunction("drawCircle",
         "Draws a circle.",
         "void drawCircle(int16_t x, int16_t y, int16_t r, uint16_t color);",
         "<ul><li><em>x</em> - x-coordinate of the circle's center</li>" +
        "<li><em>y</em> - y-coordinate of the circle's center</li>" + 
        "<li><em>r</em> - circle radius</li>" + 
        "<li><em>color</em> - circle color</li></ul>",
         "A white circle with center at (100,100) and 20px radius.",
         "tft.drawCircle(100, 100, 20, ILI9341_WHITE);", true);

        addIliFunction("fillCircle",
          "Draws a filled circle.",
         "void fillCircle(int16_t x, int16_t y, int16_t r, uint16_t color);",
         "<ul><li><em>x</em> - x-coordinate of the circle's center</li>" +
        "<li><em>y</em> - y-coordinate of the circle's center</li>" + 
        "<li><em>r</em> - circle radius</li>" + 
        "<li><em>color</em> - circle fill color</li></ul>",
         "A white filled circle with center at (100,100) and 20px radius.",
         "tft.fillCircle(100, 100, 20, ILI9341_WHITE);", true);

        addIliFunction("fillArc",
         "Draws a filled arc. Can also be used to draw a pie.",
         "void fillArc(uint16_t x, uint16_t y, uint16_t radius, uint16_t thickness, float start, float end, uint16_t color);",
         "<ul><li><em>x</em> - x-coordinate of the arc's center</li>" +
        "<li><em>y</em> - y-coordinate of the arc's center</li>" + 
        "<li><em>radius</em> - arc radius</li>" + 
        "<li><em>thickness</em> - arc inward thickness</li>" + 
        "<li><em>start</em> - arc start angle</li>" + 
        "<li><em>end</em> - arc end angle</li>" + 
        "<li><em>color</em> - arc fill color</li></ul>",
         "A white arc with center at (100,100), 20px radius, 5px thickness, starting at 45 degrees and ending at 180 degrees.</br>" + 
         "A red pie with center at (100,150), 20px radius, starting at 45 degrees and ending at 180 degrees.",
         "tft.fillArc(100, 100, 20, 5, 45, 180, ILI9341_WHITE);</br>" +
         "tft.fillArc(100, 100, 20, 20, 45, 180, ILI9341_RED);"
         , true);

        addIliFunction("drawTriangle",
         "Draws a triangle.",
        "void drawTriangle(int16_t x0, int16_t y0, int16_t x1, int16_t y1, int16_t x2, int16_t y2, uint16_t color);",
        "<ul><li><em>x0</em> - x-coordinate of triangle's 1st corner</li>" +
        "<li><em>y0</em> - y-coordinate of the triangle's 1st corner</li>" + 
        "<li><em>x1</em> - x-coordinate of triangle's 2nd corner</li>" + 
        "<li><em>y1</em> - y-coordinate of the triangle's 2nd corner</li>" + 
        "<li><em>x2</em> - x-coordinate of triangle's 3rd corner</li>" + 
        "<li><em>y2</em> - y-coordinate of the triangle's 3rd corner</li>" + 
        "<li><em>color</em> - triangle color</li></ul>",
        "A triangle defined by points (100,100) (80,130) (120,120).",
        "tft.drawTriangle(100, 100, 80, 130, 120, 120, ILI9341_WHITE);", true);

        addIliFunction("fillTriangle",
         "Draws a filled triangle.",
        "void fillTriangle(int16_t x0, int16_t y0, int16_t x1, int16_t y1, int16_t x2, int16_t y2, uint16_t color);",
        "<ul><li><em>x0</em> - x-coordinate of triangle's 1st corner</li>" +
        "<li><em>y0</em> - y-coordinate of the triangle's 1st corner</li>" + 
        "<li><em>x1</em> - x-coordinate of triangle's 2nd corner</li>" + 
        "<li><em>y1</em> - y-coordinate of the triangle's 2nd corner</li>" + 
        "<li><em>x2</em> - x-coordinate of triangle's 3rd corner</li>" + 
        "<li><em>y2</em> - y-coordinate of the triangle's 3rd corner</li>" + 
        "<li><em>color</em> - triangle fill color</li></ul>",
        "A filled triangle defined by points (100,100) (80,130) (120,120).",
        "tft.fillTriangle(100, 100, 80, 130, 120, 120, ILI9341_WHITE);", true);

        addIliFunction("drawBitmap",
        "Draws a monochrome image from a byte array. A background color can be specified, otherwise the background will be transparent.",
       "void drawBitmap(const uint8_t *bitmap, int16_t x, int16_t y, int16_t w, int16_t h, uint16_t color);</br>" +
       "void drawBitmap(const uint8_t *bitmap, int16_t x, int16_t y, int16_t w, int16_t h, uint16_t color, uint16_t bgcolor);",
       "<ul><li><em>bitmap</em> - a pointer to a byte array (in progmem for AVR) holding pixel data</li>" +
       "<li><em>x</em> - x-coordinate of the bitmaps's top left corner</li>" +
       "<li><em>y</em> - y-coordinate of the bitmaps's top left corner</li>" +
       "<li><em>w</em> - bitmap width (in pixels)</li>" +
       "<li><em>h</em> - bitmap height (in pixels)</li>" +
       "<li><em>color</em> - bitmap color (a color that will be used for drawing pixels where the corresponding bit in the array is set to 1)</li>" +
       "<li><em>bgColor</em> - bitmap's background color (optional) (a color that will be used for drawing pixels where the corresponding bit in the array is set to 0). If not specified then the background is transparent.</li><ul>",
       "Arduino logo with solid and transparent background (arrayMonochromeBitmap example sketch).",
       'const uint8_t arduLogo[] PROGMEM = {"      // width 40, height 32<br/>' +
        '  B00000000, B00000000, B00000000, B00000000, B01111110,"<br/>' +
        '  ...<br/>' +
        '   B10001010, B00101111, B00011100, B11100100, B01001110<br/>' +
        '};<br/>' +
        '  ...<br/>' +
       "tft.drawBitmap(arduLogo, 110, 100, 40, 32, ILI9341_WHITE, ILI9341_DARKCYAN); // solid background</br>" +
       "tft.drawBitmap(arduLogo, 160, 100, 40, 32, ILI9341_DARKCYAN);	// transparent background", true);

        addIliFunction("drawImage",
        "Draws an image from an array generated with BMP24toILI565Array tool.",
        "void drawImage(const uint16_t *colors, uint16_t x, uint16_t y, uint16_t w, uint16_t h);",
        "<ul><li><em>colors</em> - a pointer to an array (in progmem for AVR) holding pixel colors</li>" +
        "<li><em>x</em> - x-coordinate of the image's top left corner</li>" + 
        "<li><em>y</em> - y-coordinate of the images's top left corner</li>" + 
        "<li><em>w</em> - image width, you can use the constant generated by BMP24toILI565Array tool which is called the same as the <em>colors</em> array with <em>Width</em> appended at the end (so if colors array name is <em>myImage</em> then the width of that image is in <em>myImageWidth</em> constant)</li>" + 
        "<li><em>h</em> - image height, you can use the constant generated by BMP24toILI565Array tool which is called the same as the <em>colors</em> array with <em>Height</em> appended at the end (so if colors array name is <em>myImage</em> then the height of that image is in <em>myImageHeight</em> constant)</li></ul>",
        "3 icons from 3 arrays (arrayTftBitmap example sketch).",
        '#include "info.h<br/>#include "alert.h"<br/>#include "close.h"<br/>...<br/>' +
        "tft.drawImage(info, 100, 100, infoWidth, infoHeight);</br>" +
        "tft.drawImage(alert, 140, 100, alertWidth, alertHeight);</br>" +
        "tft.drawImage(close, 180, 100, closeWidth, closeHeight);", true);

        addIliFunction("invertDisplay",
        "Inverts display colors. Black becomes white, blue becomes yellow, etc.",
        "void invertDisplay(boolean i);",
        "<ul><li><em>i</em> - if <em>true</em> colors are inverted, if <em>false</em> - colors are normal</li></ul>",
        "Invert display colors.",
        "tft.invertDisplay(true);", true);

        addIliFunction("setRotation",
        "Sets display orientation.",
        "void setRotation(iliRotation r);",
        "<ul><li><em>r</em> - can either be one of these enum values:<br/><ul><li><em>iliRotation0</em> - portrait mode</li><li><em>iliRotation90</em> - landscape mode</li><li><em>iliRotation180</em> - portrait mode (rotated by 180 degrees)</li><li><em>iliRotation270</em> - landscape mode (rotated by 180 degrees)</li></ul>" +
        "or one of these numeric values: <br/><ul><li><em>0</em> - portrait mode</li><li><em>1</em> - landscape mode</li><li><em>2</em> - portrait mode (rotated by 180 degrees)</li><li><em>3</em> - landscape mode (rotated by 180 degrees)</li></ul></li></ul>",
        "Set rotation to landscape rotated by 180 degrees.",
        "tft.setRotation(iliRotation270); // using enum<br/>tft.setRotation(3); // using numeric value", false);

        addIliFunction("display",
        "Turns pixel display on/off. With pixel display off the screen turns white. In the off mode, the output from Frame Memory " +
        "is disabled and blank page inserted. This command makes no change of contents of frame memory.",
        "void display(boolean d);",
        "<ul><li><em>d</em> - if <em>true</em> pixel display is on (normal mode), if <em>false</em> - pixel display is off (white screen)</li></ul>",
        "Turn pixel display off.",
        "tft.display(false);", false);

        addIliFunction("idle",
        "Turns display idle mode on/off. In the idle mode, color depth is reduced. The primary and the secondary colors using MSB of each R, G and B in the Frame Memory, 8 color depth data is displayed.",
        "void idle(boolean i);",
        "<ul><li><em>i</em> - if <em>true</em> TFT will be put into idle mode, if <em>false</em> TFT will be restored to normal mode (if it was in idle mode)</li></ul>",
        "Put LCD into idle mode.",
        "tft.idle(true);", false);

        addIliFunction("sleep",
        "Turns display sleep mode on/off. In the sleep mode the LCD module enters the minimum power consumption mode. The DC/DC converter is stopped, internal oscillator is stopped and panel scanning is stopped.",
        "void sleep(boolean s);",
        "<ul><li><em>s</em> - if <em>true</em> TFT will be put into sleep mode, if <em>false</em> TFT will be restored to normal mode (if it was in sleep mode)</li></ul>",
        "Put LCD into sleep mode.",
        "tft.sleep(true);", false);

        addIliFunction("setPowerLevel",
        "Sets LCD power level.",
        "void setPowerLevel(pwrLevel p);",
        "<ul><li><em>p</em> - can be one of these values:<br/><ul><li><em>pwrLevelNormal</em> - normal mode - restores to normal mode (if it was in idle or sleep or both)</li><li><em>pwrLevelIdle</em> - idle mode - same as calling <em>idle(true)</em></li><li><em>pwrLevelSleep</em> - sleep mode - same as calling <em>sleep(true)</em></li></ul>",
        "Put LCD into sleep mode.",
        "tft.setPowerLevel(pwrLevelSleep);", false);

        addIliFunction("setSPIClockDivider",
        "Sets the SPI clock divider. That changes the clock frequency/speed at which data are sent/received to/from LCD. The higher the divider the lower the clock frequency and the drawing speed. If you have issues like LCD not working at all (white screen) or graphical artifacts then try to increase the divider (or alternatively try to improve your connections between Arduino and LCD - use the shortest cables possible and prefer soldered connections over breadboard).",
        "void setSPIClockDivider(uint8_t divider);",
        "<ul><li><em>divider</em><br/> - for Arduino Due - any number between <em>1</em> and <em>255</em><br/>" +
        "- for AVR (Uno, Mega,...) one of these values:<br/>" +
        "<ul><li><em>SPI_CLOCK_DIV2</em> - SPI clock frequency is set to (CPU frequency / 2)</li>" +
        "<li><em>SPI_CLOCK_DIV4</em> - SPI clock frequency is set to (CPU frequency / 4)</li>" +
        "<li><em>SPI_CLOCK_DIV8</em> - SPI clock frequency is set to (CPU frequency / 8)</li>" +
        "<li><em>SPI_CLOCK_DIV16</em> - SPI clock frequency is set to (CPU frequency / 16)</li>" +
        "<li><em>SPI_CLOCK_DIV32</em> - SPI clock frequency is set to (CPU frequency / 32)</li>" +
        "<li><em>SPI_CLOCK_DIV64</em> - SPI clock frequency is set to (CPU frequency / 64)</li>" +
        "<li><em>SPI_CLOCK_DIV128</em> - SPI clock frequency is set to (CPU frequency / 128)</li></ul></li></ul>",
        "SPI clock frequency set to approx. 8 MHz.",
        "tft.setSPIClockDivider(10); // for Arduino Due 84MHz/10 = 8.4MHz</br>" +
        "tft.setSPIClockDivider(SPI_CLOCK_DIV2); // for Arduino Uno, Mega,... 16MHz/2 = 8MHz", false);

        addIliFunction("setAngleOffset",
        "Sets the offset in degrees from the default position (set by ARC_ANGLE_OFFSET in ILI9341_due_config.h) where the arc will start (representing arc angle of 0 degrees). If you imagine a compass then the default starting position is at the North point (the arc will start from the top). Setting the offset to 90 degrees will move the starting point 90 degress clockwise so to the East point (the arc will start from the right side), etc.",
        "void setAngleOffset(int16_t angleOffset);",
        "<ul><li><em>angleOffset</em> - clokwise offset in degrees from the default start point (North point). Can be a negative number which will offset angle's 0 degree position counter-clockwise from the default start point.</li></ul>",
        "Set the red arc angle start point to West.<br/>Set the yellow arc angle start point to 45 degrees clockwise from North.<br/>Set the blue arc angle start point to default.",
        "tft.setAngleOffset(-90);<br/>tft.drawArc(100, 150, 50, 10, 0, 25, ILI9341_RED);</br>" +
        "tft.setAngleOffset(45);<br/>tft.drawArc(100, 200, 50, 10, 0, 25, ILI9341_YELLOW);</br>" +
        "tft.setAngleOffset(0);<br/>tft.drawArc(100, 100, 50, 10, 0, 25, ILI9341_BLUE);", true);

        addIliFunction("setArcParams",
        "Sets parameters for drawing arcs. For now it has only one param to set.",
        "void setArcParams(float arcAngleMax);",
        "<ul><li><em>arcAngleMax</em> - sets the max value corresponding to 360 degrees. By default it is set to value defined by ARC_ANGLE_MAX in ILI9341_due_config.h which is 360. You can set it to any float value, so for example if you set it to 1.0 (which will represent the max angle of 360) then calling fillArc with startAngle of 0 and endAngle of 0.5 then you will get a half circle.</li></ul>",
        "Set the max angle to 100 so we can draw arcs using percentages. Then draw an arc with 'angle' of 25% which will draw quarter of a circle.",
        "tft.setArcParams(100);<br/>tft.drawArc(100, 150, 50, 10, 0, 25, ILI9341_WHITE);", true);

        addIliFunction("setAddrWindow",
        "Sets the drawing window for pushPixel and pushPixels.",
        "void setAddrWindow(uint16_t x0, uint16_t y0, uint16_t x1, uint16_t y1);",
         "<ul><li><em>x0</em> - x-coordinate of the upper left corner of the drawing window</li>" +
        "<li><em>y0</em> - y-coordinate of the upper left corner of the drawing window</li>" +
        "<li><em>x1</em> - x-coordinate of the bottom right corner of the drawing window</li>" +
        "<li><em>y1</em> - y-coordinate of the bottom right corner of the drawing window</li></ul>",
        "Set the drawing window to draw between point (100,100) and (120, 130).",
        "tft.setAddrWindow(100, 100, 120, 130);", true);


    </script>



</body>
</html>
