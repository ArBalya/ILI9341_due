<!DOCTYPE html>
<html>

<head>
    <meta charset='utf-8'>
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <meta name="description" content="ILI9341_due : Arduino Due library for interfacing with ILI9341 SPI TFTs">

    <script src="javascripts\lodash.js" type="text/javascript"></script>
    <link rel="stylesheet" type="text/css" media="screen" href="stylesheets/stylesheet.css">

    <title>ILI9341_due</title>
</head>

<body>

    <!-- HEADER -->
    <div id="header_wrap" class="outer">
        <header class="inner">
            <a id="forkme_banner" href="https://github.com/marekburiak/ILI9341_due">View on GitHub</a>

            <h1 id="project_title">ILI9341_due</h1>
            <h2 id="project_tagline">Arduino Due library for interfacing with ILI9341 SPI TFTs</h2>

            <section id="downloads">
                <a class="zip_download_link" href="https://github.com/marekburiak/ILI9341_due/zipball/master">Download this project as a .zip file</a>
                <a class="tar_download_link" href="https://github.com/marekburiak/ILI9341_due/tarball/master">Download this project as a tar.gz file</a>
            </section>
        </header>
    </div>



    <!-- MAIN CONTENT -->
    <div id="main_content_wrap" class="outer">
        <section id="main_content" class="inner">
            <h1>
                <a name="ili9341_due" class="anchor" href="#ili9341_due"><span class="octicon octicon-link"></span></a>ILI9341_due
            </h1>

            <p>Arduino Due library for interfacing with ILI9341-based TFT's in SPI, Extended SPI and DMA SPI mode.</p>

            <p>This library is based on 3 libraries:</p>

            <p>
                <b>ili9341_t3</b> from Paul Stoffregen - <a href="https://github.com/PaulStoffregen/ILI9341_t3">https://github.com/PaulStoffregen/ILI9341_t3</a><br>
                <b>SdFat</b> from Bill Greiman - <a href="https://github.com/greiman/SdFat">https://github.com/greiman/SdFat</a><br>
                <b>GLCD</b> from Michael Margolis and Bill Perry - <a href="https://code.google.com/p/glcd-arduino">https://code.google.com/p/glcd-arduino</a><br>
            </p>

            <p>
                ili9341_t3 library where various optimizations for Adafruit's ili9341 and GFX libraries were implemented was used as a base for ili9341_due.<br>
                One class from SdFat library is used for utilizing Due's DMA in SPI transfers which provides the main speed boost.<br>
                gText class from GLCD library was used as a base for rendering custom fonts.
            </p>

            <p>
                As for the wiring, use Due's HW SPI pins (e.g. described <a href="http://21stdigitalhome.blogspot.com/2013/02/arduino-due-hardware-spi.html">here</a>). A pin for CS depends on the SPI mode you choose.
                If you look into ILI9341_due.h, you should find this:
            </p>

            <pre lang="Arduino"><code>// comment out the SPI mode you want to use
//#define ILI9341_SPI_MODE_NORMAL
//#define ILI9341_SPI_MODE_EXTENDED // make sure you use pin 4, 10 or 52 for CS
#define ILI9341_SPI_MODE_DMA</code></pre>

            <p>Uncomment the line depending on the SPI mode you want to use. As you can see, DMA mode is the default.</p>

            <p>
                <b>SPI_MODE_NORMAL</b> is the standard SPI mode where you can use any digital pin for CS but you/library has to drive it manually.<br>
                <b>SPI_MODE_EXTENDED</b> is the extended SPI mode available in Due where CS pin is handled by the chip (which is faster than handling it manually). You are restricted to these pins for CS though - 4, 10 and 52 (as described <a href="http://arduino.cc/en/Reference/DueExtendedSPI">here</a>).<br>
                <b>SPI_MODE_DMA</b> is utilizing DMA to do SPI transfers. You should be able to use any digital pin for CS.
            </p>

            <p>
                Here is a video where you can see the speed difference between the modes:
            </p>
            <div style="text-align: center">
                <iframe width="560" height="315" src="http://www.youtube.com/embed/vnEwzN14BsU?rel=0&color=white" frameborder="0"></iframe>
            </div>
            <br />
            <pre lang="Arduino"><code>#define ILI9341_SPI_CLKDIVIDER 2</code></pre>

            <p>This is used to set the SPI clock frequency, which at 2 means 84/2=42MHz (the max). If you are getting glitches on the screen or it just does not work try to use a higher divider to bring the frequency down (e.g. 11 to run it at 8-ish MHz). I was using 20cm dupont cables to connect TFT with Due and haven't had any issues running it with the divider set to 2.</p>

            <p>If you want to ask me a question or just contact me, feel free to do so in the <a href="http://forum.arduino.cc/index.php?topic=265806.0">Arduino Forum</a>.</p>

            <h3>ILI9341 functions</h3>

            <div id="iliFunctions">

            </div>

            <h3>Rendering custom fonts with ILI9341_due_gText</h3>

            <p>
                You have two options for rendering fonts. Either use text functions from ILI9341_due library where you have one font available (same as in Adafruit's GFX library) or use ILI9341_due_gText class to render your custom fonts.
                The maximum height of the font is 255px. Custom font .h files can be generated with GLCDFontCreator2 tool (requires Java). It is included in the tools folder or you can dowload it from
                <a href="https://code.google.com/p/glcd-arduino/downloads/detail?name=GLCDFontCreator2.zip&amp;can=2&amp;q=">here</a>.<br>
                Here is a video of rendering a 255px-high font:
            </p>
            <div style="text-align: center">
                <iframe width="560" height="315" src="http://www.youtube.com/embed/OcTz_YBDXmo?rel=0&color=white" frameborder="0"></iframe>
            </div>
            <h3>Loading images from an SD card</h3>

            <p>This is the SdFatTftBitmap example sketch demonstrating loading images from an SD card. The images were converted to RGB565 format using BMP24toILI565 tool (see the Tools folder). One image loads and displays in around 190ms (using half speed for SD card SPI as the full speed did not work for me, probably because the SD card pins were connected to Due via a breadboard).</p>
            <div style="text-align: center">
                <iframe width="560" height="315" src="http://www.youtube.com/embed/4adTpVc_Qog?rel=0&color=white" frameborder="0"></iframe>
            </div>
            <h3>Drawing Arcs</h3>
            <p>You can use the <i>drawArc</i> method to draw arcs (with thickness) and depending on the thickness and angles you provide as parameters you might also draw pies and circles with thickness.</p>
            <p>ILI9341_due.h has two defines which you can customize:</p>

            <pre lang="Arduino"><code>#define ARC_ANGLE_MAX 360</code></pre>
            <p>
                This number represents the maximum equal to 360 degrees (full circle). The default is 360 so if you pass in start=25 and end=75 you'll get an arc going from 25 degrees to 75 degrees.
                If you set ARC_ANGLE_MAX 100 and you pass in start=0 and end=50 then you get a half circle (that can represent percentages). If you set ARC_ANGLE_MAX 2*PI, you can pass in
                angles in radians etc...
            </p>

            <pre lang="Arduino"><code>#define ARC_ANGLE_OFFSET -90</code></pre>

            <p>This number is an offset in degrees from the default position where the arc starts (representing value of 0). If you imagine a compass, then the default starting position is at the East point. Setting the value to -90 will move the starting point 90 degress counter-clockwise (so to the North point).</p>
            <p>You can change these defaults at runtime by calling setArcParams function.</p>

            <p>This is the Arcs demo from the examples folder:</p>
            <div style="text-align: center">
                <iframe width="560" height="315" src="http://www.youtube.com/embed/99todZeKaeI?rel=0&color=white" frameborder="0"></iframe>
            </div>
            <h3>Taking screenshots</h3>

            <p>
                The library has a method called <i>screenshotToConsole</i>. When you call that method, you should get a string like this one in the console window:
            </p>

            <pre lang="Arduino"><code>==== PIXEL DATA START ====
0000000090606060001F000000011B606060002B0000000
11060606000350000000107606060003D00000000FF6060
60004500000000F86060600016000000001F60606000160
...                                     
0000000F26060600013000000002B606060001300000000
EC6060600011000000001B7C7E7C000E000000000C60606
06060002B000000011B606060001F00000001D1000050F0
==== PIXEL DATA END ====</code></pre>

            <p>
                Now, copy all between PIXEL DATA START and END (so starting with 0000... and ending with ...50F0) into the clipboard.<br />
                Open ILIScreenshotViewer (from the tools folder) and click "Load Image from Clipboard" button. You should then see an image
                of what was on the screen when you called <i>screenshotToConsole</i> method.
            </p>
            <div style="text-align: center">
                <img src="images\ILIScreenshotViewer.png" />
            </div>
            <p>You can then click "Save As..." button to save the image in bmp, gif, png or jpg format.</p>
            <p>
                A couple of tips:
                <ul>
                    <li>
                        Use some higher Serial speed. Depending on the image, the "screenshot" string might get long (in kB) so I guess transferring it at 115200b/s is better than at 9600b/s.
                    </li>
                    <li>
                        If your get an error after you click the Load Image from Clipboard button or your image has artifacts, try lowering the SPI clock before you call screenshotToConsole method.
                        Something like this:
                        <pre lang="Arduino"><code>tft.setSPIClockDivider(24);  // lower the frequency
tft.screenshotToConsole();   // take a "screenshot"
tft.setSPIClockDivider(ILI9341_SPI_CLKDIVIDER); // restore the frequency</code></pre>
                    </li>
                </ul>
            </p>

            <h3>UTFT demo speed comparison</h3>

            <p>All the credits (and blame :) goes to TFTLCDCyg who ported the UTFT demo to ILI9341_due library. Both demos were run on Due at the max speed.</p>
            <p>Here is a video of the demo powered by the UTFT library:</p>
            <div style="text-align: center">
                <iframe width="560" height="315" src="http://www.youtube.com/embed/ZYW9f8Q_b-Q?rel=0&color=white" frameborder="0"></iframe>
            </div>
            <p>And here is the demo powered by the ILI9341_due library:</p>
            <div style="text-align: center">
                <iframe width="560" height="315" src="http://www.youtube.com/embed/xkPDAK0VJq0?rel=0&color=white" frameborder="0"></iframe>
            </div>
            <p>The source code for the ILI9341_due-fied demo can be found in the library's examples folder.</p>

            <h3>AVR compatibility</h3>

            <p>The library can also be used with Arduino AVR boards like Uno, Mega, Pro Mini, Nano, etc.</p>
            <div style="text-align: center">
                <img src="images\avr.jpg" />
            </div>
            <p>
                The only mode available for AVR is SPI_MODE_NORMAL so you need to include SPI.h in your sketch. The library is faster than the original Adafruit one but do not expect DMA-like speed increase. It is comparable to some other tweaked Adafruit libraries out there and you get things like gText and arcs.
                Not all library examples will work. It is because of smaller ROM/RAM space available on AVRs.
            </p>
            <p>
                In order to decrease ROM/RAM requirements, you can comment out 2 features in ILI9341_due.h:
                <pre lang="Arduino"><code>// commenting out/disabling the ARC feature will exclude the drawArc function. It is going to save a few ROM bytes.
#define FEATURE_ARC_ENABLED
// commenting out/disabling the PRINT feature will exclude the drawChars and print functions, it saves around 3.6kB ROM and 1.3kB RAM(!)
// I recommend using gText for drawing the text.
#define FEATURE_PRINT_ENABLED</code></pre>
                I highly recommend to disable the PRINT feature if you are not using .print function (to draw blocky text). It will save you 1.3kB of RAM (of 2kB available on Uno). You can use gText instead.
            </p>
            <p>
                <h4>Using gText on AVR</h4>
                If you are using your custom fonts (generated with GLCDFontCreator2) you need to manually modify the generated .c file in order to make it succesfully compile for AVR. After you generate the .c file the array definition will look something like this:
            </p>
            <pre lang="Arduino"><code>static uint8_t Arial_14[] PROGMEM = {</code></pre>

            <p>
                If you do not change anything the compiler will complain with:
            </p>
            error: variable 'Arial_14' must be const in order to be put into read-only section by means of '__attribute__((progmem))'<br /><br />
            In order to fix it you need to add "const" so it will look like this:

            <pre lang="Arduino"><code>static const uint8_t Arial_14[] PROGMEM = {</code></pre>

            <br />
            <h3>Known bugs/issues/missing functionality</h3>

            <ul>
                <li>I am sure there are bugs, feel free to fix them</li>
                <li>New line is not handled when rendering with gText</li>
            </ul>
            <p>I plan to add some more features (like handling the new line and scrolling in gText) but I am not sure when will that happen as I have very little time to work on it (if I want to get at least 5 hours of sleep). So feel free to enhance the lib.</p>

            <pre><code>------------------------------------------
This is a library for the Adafruit ILI9341 display products
This library works with the Adafruit 2.8" Touch Shield V2 (SPI)
  ----&gt; http://www.adafruit.com/products/1651
Check out the links above for our tutorials and wiring diagrams.
These displays use SPI to communicate, 4 or 5 pins are required
to interface (RST is optional).
Adafruit invests time and resources providing this open source code,
please support Adafruit and open-source hardware by purchasing
products from Adafruit!
Written by Limor Fried/Ladyada for Adafruit Industries.
MIT license, all text above must be included in any redistribution
</code></pre>
        </section>
    </div>

    <!-- FOOTER  -->
    <div id="footer_wrap" class="outer">
        <footer class="inner">
            <p class="copyright">ILI9341_due maintained by <a href="https://github.com/marekburiak">Marek Buriak</a></p>
            <p>Published with <a href="http://pages.github.com">GitHub Pages</a></p>
        </footer>
    </div>

    <div class="function">
        <div class="functionHeader">
            drawLine
        </div>
        <div class="functionDescription">
            Draws a line defined by start and end points.
        </div>
        <div class="functionExample">
            <div class="functionExampleDescription">

            </div>
            <div class="functionExampleCode">

            </div>
        </div>
        <div class="functionImage">
            <img src="images\func_drawLine.png" />
        </div>
    </div>

    <script type="text/javascript">
        function addIliFunction(functionName, functionDescription, functionDeclarationCode, functionExampleDesc, functionExampleCode, functionExampleImage) {
            var funcs = document.getElementById("iliFunctions");
            var funcElem = document.createElement("div");
            funcElem.className = "function";

            var funcHeader = document.createElement("div");
            funcHeader.className = "functionHeader";
            funcHeader.appendChild(document.createTextNode(functionName));

            var funcContent = document.createElement("div");
            funcContent.className = "functionContent";

            var funcDesc = document.createElement("div");
            funcDesc.className = "functionDescription";
            funcDesc.appendChild(document.createTextNode(functionDescription));

            var funcDeclaration = document.createElement("div");
            funcDeclaration.className = "functionCode";
            if (_.isArray(functionDeclarationCode)) {
                _.forEach(functionDeclarationCode, function (functionDeclaration) {

                    var funcDeclarationOne = document.createElement("div");
                    funcDeclarationOne.appendChild(document.createTextNode(functionDeclaration));
                    funcDeclaration.appendChild(funcDeclarationOne);
                })
            }
            else {
                funcDeclaration.appendChild(document.createTextNode(functionDeclarationCode));
            }

            var funcExample = document.createElement("div");
            funcExample.className = "functionExample";
            var funcExampleTitle = document.createElement("div");
            funcExampleTitle.className = "functionExampleTitle";
            funcExampleTitle.appendChild(document.createTextNode("Example:"));

            var funcExampleDesc = document.createElement("div");
            funcExampleDesc.className = "functionExampleDescription";
            funcExampleDesc.appendChild(document.createTextNode(functionExampleDesc));
            var funcExampleCode = document.createElement("div");
            funcExampleCode.className = "functionCode";
            if (_.isArray(functionExampleCode)) {
                _.forEach(functionExampleCode, function (functionExample) {

                    var funcExampleOne = document.createElement("div");
                    funcExampleOne.appendChild(document.createTextNode(functionExample));
                    funcExampleCode.appendChild(funcExampleOne);
                })
            }
            else {
                funcExampleCode.appendChild(document.createTextNode(functionExampleCode));
            }
            var funcExampleImage = document.createElement("div");
            funcExampleImage.className = "functionExampleImage";
            var funcExampleImageImg = document.createElement("img");
            if (typeof functionExampleImage !== "undefined")
                funcExampleImageImg.setAttribute("src", ".\\images\\" + functionExampleImage);
            else
                funcExampleImageImg.setAttribute("src", ".\\images\\func_" + functionName + ".png");
            funcExampleImage.appendChild(funcExampleImageImg);

            funcExample.appendChild(funcExampleTitle);
            funcExample.appendChild(funcExampleDesc);
            funcExample.appendChild(funcExampleCode);
            funcExample.appendChild(funcExampleImage);


            funcContent.appendChild(funcDesc);
            funcContent.appendChild(funcDeclaration);
            funcContent.appendChild(funcExample);

            funcElem.appendChild(funcHeader);
            funcElem.appendChild(funcContent);
            funcs.appendChild(funcElem);
        }

        addIliFunction("fillScreen",
         "Fills/clears the whole screen with a specified color.",
        "void fillScreen(uint16_t color);",
        "A screen filled with blue color.",
        "tft.fillScreen(ILI9341_BLUE);");

        addIliFunction("drawPixel",
         "Draws a pixel at the specified position.",
         "void drawPixel(int16_t x, int16_t y, uint16_t color);",
         "A pixel at position (100,100).",
         "tft.drawPixel(100, 100, ILI9341_WHITE);");

        addIliFunction("drawLine",
            "Draws a line defined by a start point and an end point.",
            "void drawLine(int16_t x0, int16_t y0, int16_t x1, int16_t y1, uint16_t color);",
            "A line from point (100,100) to point (150,120)",
            "tft.drawLine(100, 100, 150, 120, ILI9341_WHITE);");

        addIliFunction("drawLineByAngle",
       "Draws a line defined by a start point and an angle. An offset from the start point can be defined.",
       ["void drawLineByAngle(int16_t x, int16_t y, int16_t angle, uint16_t length, uint16_t color);",
       "void drawLineByAngle(int16_t x, int16_t y, int16_t angle, uint16_t start, uint16_t length, uint16_t color);"],
       "A white line from point (100,100) at 45 degree angle and 50px length. A red line from point (100,100) at 90 degree angle starting 10px from the start point and length of 50px.",
       ["tft.drawLineByAngle(100, 100, 45, 50, ILI9341_WHITE);",
       "tft.drawLineByAngle(100, 100, 90, 10, 50, ILI9341_RED);"]);

        addIliFunction("drawFastHLine",
           "Draws a horizontal line. Performance optimized version of drawLine.",
           "void drawFastHLine(int16_t x, int16_t y, uint16_t w, uint16_t color);",
           "A horizontal line from point (100,100) of 50px length.",
           "tft.drawFastHLine(100, 100, 50, ILI9341_WHITE);");

        addIliFunction("drawFastVLine",
          "Draws a vertical line. Performance optimized version of drawLine.",
          "void drawFastVLine(int16_t x, int16_t y, uint16_t h, uint16_t color);",
          "A vertical line from point (100,100) of 50px length.",
          "tft.drawFastVLine(100, 100, 50, ILI9341_WHITE);");

        addIliFunction("drawRect",
          "Draws a rectangle from the specified position and of specified width and height.",
          "void drawRect(int16_t x, int16_t y, int16_t w, int16_t h, uint16_t color);",
          "A rectangle from point (100,100) of 50px width and 20px height.",
          "tft.drawRect(100, 100, 50, 20, ILI9341_WHITE);");

        addIliFunction("fillRect",
         "Draws a filled rectangle from the specified position and of specified width and height.",
         "void fillRect(int16_t x, int16_t y, int16_t w, int16_t h, uint16_t color);",
         "A filled rectangle from point (100,100) of 50px width and 20px height.",
         "tft.fillRect(100, 100, 50, 20, ILI9341_WHITE);");

        addIliFunction("drawRoundRect",
          "Draws a rectangle with rounded edges of specified radius from the specified position and of specified width and height.",
          "void drawRoundRect(int16_t x0, int16_t y0, int16_t w, int16_t h, int16_t radius, uint16_t color);",
          "A rounded rectangle from point (100,100) of 50px width, 20px height and rounded edges of 7px radius.",
          "tft.drawRoundRect(100, 100, 50, 20, 7, ILI9341_WHITE);");

        addIliFunction("fillRoundRect",
         "Draws a filled rectangle with rounded edges of specified radius from the specified position and of specified width and height.",
         "void fillRoundRect(int16_t x0, int16_t y0, int16_t w, int16_t h, int16_t radius, uint16_t color);",
         "A filled rounded rectangle from point (100,100) of 50px width, 20px height and rounded edges of 7px radius.",
         "tft.fillRoundRect(100, 100, 50, 20, 7, ILI9341_WHITE);");

        addIliFunction("drawCircle",
         "Draws a circle at specified position and of specified radius.",
         "void drawCircle(int16_t x, int16_t y, int16_t r, uint16_t color);",
         "A circle with center at (100,100) and 20px radius.",
         "tft.drawCircle(100, 100, 20, ILI9341_WHITE);");

        addIliFunction("fillCircle",
          "Draws a circle at specified position and of specified radius.",
         "void fillCircle(int16_t x, int16_t y, int16_t r, uint16_t color);",
         "A circle with center at (100,100) and 20px radius.",
         "tft.fillCircle(100, 100, 20, ILI9341_WHITE);");

        addIliFunction("drawTriangle",
         "Draws a triangle specified by 3 points.",
        "void drawTriangle(int16_t x0, int16_t y0, int16_t x1, int16_t y1, int16_t x2, int16_t y2, uint16_t color);",
        "A triangle defined by points (100,100) (80,130) (120,120).",
        "tft.drawTriangle(100, 100, 80, 130, 120, 120, ILI9341_WHITE);");

        addIliFunction("fillTriangle",
         "Draws a filled triangle specified by 3 points.",
        "void fillTriangle(int16_t x0, int16_t y0, int16_t x1, int16_t y1, int16_t x2, int16_t y2, uint16_t color);",
        "A filled triangle defined by points (100,100) (80,130) (120,120).",
        "tft.fillTriangle(100, 100, 80, 130, 120, 120, ILI9341_WHITE);");





    </script>



</body>
</html>
